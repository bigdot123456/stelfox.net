---
hidden: true
---
<%

require 'redcarpet/render_strip'

class ContentRenderer < Redcarpet::Render::StripDown
  def block_code(*args)
    nil
  end

  def list_item(content, list_type)
    content.gsub("\n", " ") + "\n\n"
  end

  def paragraph(text)
    text.gsub("\n", " ") + "\n\n"
  end
end

# Start with a base index
index = {
  pages: [],
  weights: {}
}

markdown = Redcarpet::Markdown.new(ContentRenderer, fenced_code_blocks: true)

# Loop through all the non-binary documents, for indexing
@items.each do |i|
  next if i.binary?
  next unless i.raw_content
  next unless i[:title]

  # Create and store the ID of the path
  index[:pages].push({
    title: i[:title],
    path: i.path
  })
  page_id = index[:pages].size - 1

  markdown.render(i.raw_content).split(/\s+/).each do |word|
    word.downcase!
    word.gsub!(/[.,?!;"-'`*_]/, "") # Strip out any punctuation or markdown symbols
    word.strip!

    next unless word =~ /\A[a-z]{3,}\Z/
    next if STOP_WORDS.include?(word)

    index[:weights][word] ||= {}
    index[:weights][word][page_id] ||= 0
    index[:weights][word][page_id] += ((i[:tags] || []).include?(word) ? 5 : 1)
  end

  # Clean up any weights under the threshold, this makes the search less
  # accurate especially for highly specific words, but leaving it out
  # increases the index size by ~150%
  index[:weights].each do |word, path_weights|
    path_weights.each do |path, weight|
      index[:weights][word].delete(path) if weight <= 1
    end

    if index[:weights][word].empty?
      index[:weights].delete(word)
    end
  end
end
%>
<%= JSON.generate(index) %>
