<!DOCTYPE html>
<html lang='en_US'>
  <head>
    <title>Bash - Stelfox Athen&#xe6;um</title>

    <meta http-equiv='content-type' content='text/html; charset=utf-8' />
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1' />
    
    

    <link rel="alternate" type="application/atom+xml" title="Stelfox Athen&#xe6;um Feed" href="/atom.xml" />
    <link rel="canonical" href="https://stelfox.net" />
    <link rel="author" href="https://plus.google.com/+SamStelfox31337/"/>

    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Bash" />
    <meta property="og:url" content="https://stelfox.net/tags/bash/" />
    <meta property="og:site_name" content="Stelfox Athen&#xe6;um" />
    <meta property="article:publisher" content="https://www.facebook.com/sstelfox" />
    <meta property="og:image" content="https://stelfox.net/static/avatar-01.jpg" />

    <meta name="go-import" content="stelfox.net git io:repos/" />

    <link rel='stylesheet' href="//fonts.googleapis.com/css?family=Open+Sans:300,400italic,400,600,700|Alegreya+SC:700" />
    <link rel="stylesheet" href="https://stelfox.net/css/3HrCRVwL3Gos2V4HzXAw/Om/nxs=.css" />

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-32188490-1', 'stelfox.net');
      ga('require', 'displayfeatures');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header class='masthead'>
      <div class='masthead-inner'>
        <h1><a href='/' title='Home'>Sam Stelfox</a></h1>
        <p class='lead'>Thoughts from a systems hacker and developer.</p>
        <nav>
          <ul>
            <li><a href="/about/" title="About">About</a></li>
            <li><a href="/blog/" title="Blog">Blog</a></li>
            <li><a href="/knowledge_base/" title="Knowledge Base">Knowledge Base</a></li>
            <li><form action="/search/" method="get"><input type="search" name="q" placeholder="Search" /></form></li>
          </ul>
        </nav>
        <footer class='colophon'>
          <p>&copy; 2014, All rights reserved.</p>
        </footer>
      </div>
    </header>
    <div class='content container'>
      <div class="post">
  <h1>Bash</h1>
  
    <div class='post'>
      <h2><a href="/blog/2014/05/chain-loading-kernels/">Chain Loading Kernels</a></h1>
      <aside>Posted at: 2014-05-23 11:39:16 -0400</aside>
      <article>
        <p>I&#39;ve found several places where I needed to be able to update my kernels but
for one reason or another can&#39;t update the kernel that gets booted initially. A
couple of these situations were:</p>

<ul>
<li>Running Custom or Updated Kernels on DigitalOcean (this is one of their
biggest failings IMHO)</li>
<li>Allowing updating of kernels on embedded linux devices that require their
kernel flashed into NVRAM.</li>
<li>Running an embedded system that used an active/backup partition scheme for
updating.</li>
</ul>

<p>In all cases the process was pretty much the same, though there were some
custom changes to the preliminary init system depending on what I needed to get
done, especially with the last one which I may cover in a different article.</p>

<p>In all cases these were done on a RedHat based distribution like CentOS,
Scientific Linux, RHEL, or even Fedora. For those users of Debian based systems
you&#39;ll need to adjust the scripts too your system though I can&#39;t imagine
anything other than the package names changing.</p>

<p>This assumes you already have the kernel and initramfs you want to boot
installed on your local filesystem at <code>/boot/vmlinuz-custom</code> and
<code>/boot/initramfs.img</code>.</p>

<p>A quick background on how this works, when the linux kernel is compiled an init
program is configured to be the first thing triggered, by default and in most
situations this will be the executable <code>/sbin/init</code>. This init process is then
responsible for starting the rest of the daemons and processes that make up the
systems we regularly interact with.</p>

<p>There are tools that allow you too effectively execute another kernel to run in
place of the kernel that is already running. There are some catches though as
the new kernel won&#39;t always re-initialize all devices (since they&#39;ve already
been initialized) and that can lead too some weird behaviors with processes
that already have hooks on those devices.</p>

<p>Too prevent any issues you need to load the new kernel as early in the boot
process as possible. Doing this in the init program is pretty much as early as
you can get and makes for a pretty stable system (I&#39;ve yet to experience any
issues with machines running this way).</p>

<p>There are several different init systems and they all behave a little
differently, as far as I know only systemd supports a means of automatically
executing a different kernel but I am personally not a systemd fan and it would
be too late in the boot process already for me too trust the chain load. You
can reliably chain load kernels regardless of what your normal init system is
though very easily and that&#39;s what I&#39;m going to cover here.</p>

<p>You&#39;ll need to have the kexec tools installed on your system. This is pretty
straight-forward:</p>
<div class="CodeRay">
  <div class="code"><pre>yum install kexec-tools -y
</pre></div>
</div>

<p>Next we&#39;re going to shift the standard init process off to the side, someplace
still accessible so we can call it later (this will need to be done as root).</p>
<div class="CodeRay">
  <div class="code"><pre>mv /sbin/init /sbin/init.original
</pre></div>
</div>

<p>Now we need to create our own init script that will handle detecting if it&#39;s
the new or old kernel, replacing the kernel if it is indeed an old one, and
starting up the normal init process if it&#39;s the new kernel.</p>

<p>Now there is a very important catch here, whatever process starts up first is
given PID 1 which is very important in kernel land. Whatever process is PID 1
will inherit all zombie processes on the system and will need to handle them.
Since our shell script is the first thing started up it will get PID 1 for both
the old and new kernel and getting the process handling code correct is not a
trivial issue.</p>

<p>What we really need is to hand over PID 1 to the init process so it can do it&#39;s
job normally as if the shell script never existed. There is a native function
to do exactly this in these shell scripts: <code>exec</code>.</p>

<p>Our simple shell script to do the chain load looks like this:</p>
<div class="CodeRay">
  <div class="code"><pre>#!/bin/bash

# Detect if this is the old kernel (not booted with the otherwise meaningless
# 'kexeced' parameter.
if [ $(grep -q ' kexeced$' /proc/cmdline) ]; then
  kexec --load /boot/vmlinuz-custom --initrd=/boot/initramfs.img \
    --reuse-cmdline --append=' kexeced'
  kexec --exec
fi

# If we made it this far we're running on the new kernel, trigger the original
# init binary with all the options passed too this as well as having it take
# over this process's PID.
exec /sbin/init.original &quot;$@&quot;
</pre></div>
</div>

<p>After rebooting you should be in your new kernel which you can verify with
<code>uname -a</code> and also by examining the <code>/proc/cmdline</code> file for the existence of
the &#39;kexeced&#39; flag.</p>

<p>If you modify the script above, be very careful as any execution error will
cause your system to die and recovery will only be possible by mounting the
filesystem on another linux system and fixing it.</p>

<p>In a future article I&#39;ll cover how to use this trick to build an active /
backup system allowing you to fall back to a known good system when booting
fails which is incredibly useful for embedded devices in the field that need
updates but are not easy to get too or replace when an update bricks the
system.</p>

      </article>
    </div>
  
    <div class='post'>
      <h2><a href="/blog/2013/11/fail-fast-in-bash-scripts/">Fail Fast in Bash Scripts</a></h1>
      <aside>Posted at: 2013-11-26 15:19:40 -0500</aside>
      <article>
        <p>I found myself writing another bash script that should exit should any of the
few commands within it fail to run. As I began writing some error handling
after each command, and isolating the sections into bash functions I figured
there had to be a better way. After a little Googling and a trip through the
bash manpages sure enough:</p>
<div class="CodeRay">
  <div class="code"><pre>#!/bin/bash

function error_handler() {
  echo &quot;Error occurred in script at line: ${1}.&quot;
  echo &quot;Line exited with status: ${2}&quot;
}

trap 'error_handler ${LINENO} $?' ERR

set -o errexit
set -o errtrace
set -o nounset

echo &quot;Everything is running fine...&quot;

# A command outside of a conditional that will always return a exit code of 1
test 1 -eq 0

echo &quot;This will never run, as a command has failed&quot;
echo &quot;Using unset variable ${TEST} will also cause this script to exit&quot;
</pre></div>
</div>

<p>The first piece of that is setting up an error handler that will get run
whenever an error condition occurs with the script. You can use this section to
roll back any changes or cleanup your environment as well as give you some
debug information about the failure.</p>

<p>I&#39;m then setting a few bash options, The following is a description taken more
or less directly from the bash man pages:</p>

<blockquote>
<p>-o errexit: Exit immediately if a pipeline (which may consist of a single
simple command), a subshell command enclosed in parentheses, or one of the
commands executed as part of a command list enclosed by braces exits with a
non-zero status.</p>

<p>-o errtrace: If set, any trap on ERR is inherited by shell functions, command
substitutions, and commands execute in a subshell environment.</p>

<p>-o nounset: Treat unset variables and parameters other than the special
parameters &quot;@&quot; and &quot;*&quot; as an error when performing parameter expansion.</p>
</blockquote>

<p>If anything goes wrong in the script it will fail once, fail fast, and let you
know where it died.</p>

      </article>
    </div>
  
    <div class='post'>
      <h2><a href="/blog/2014/08/fast-hex-to-decimal-in-bash/">Fast Hex to Decimal in Bash</a></h1>
      <aside>Posted at: 2014-08-01 19:50:24 -0400</aside>
      <article>
        <p>I needed too turn some hexidecimal values into decimal in a bash script and
found a real easy way too do it. The following is a very short bash script
demostrating how too turn the hexidecimal string &quot;deadbeefcafe&quot; into it&#39;s
equivalent decimal value of &quot;244837814094590&quot;.</p>
<div class="CodeRay">
  <div class="code"><pre>#!/bin/bash

INPUT=&quot;deadbeefcafe&quot;
OUTPUT=$((0x${INPUT}))

echo $OUTPUT
</pre></div>
</div>

      </article>
    </div>
  
</div>

    </div>
  </body>
</html>
