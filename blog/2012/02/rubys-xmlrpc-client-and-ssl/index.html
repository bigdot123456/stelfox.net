<!DOCTYPE html>
<html lang='en_US'>
  <head>
    <title>Ruby's XMLRPC::Client and SSL - Stelfox Athen&#xe6;um</title>

    <meta http-equiv='content-type' content='text/html; charset=utf-8' />
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1' />
    
    

    <link rel="alternate" type="application/atom+xml" title="Stelfox Athen&#xe6;um Feed" href="/atom.xml" />
    <link rel="canonical" href="https://stelfox.net" />
    <link rel="author" href="https://plus.google.com/+SamStelfox31337/"/>

    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Ruby's XMLRPC::Client and SSL" />
    <meta property="og:url" content="https://stelfox.net/blog/2012/02/rubys-xmlrpc-client-and-ssl/" />
    <meta property="og:site_name" content="Stelfox Athen&#xe6;um" />
    <meta property="article:publisher" content="https://www.facebook.com/sstelfox" />
    <meta property="og:image" content="https://stelfox.net/static/avatar-01.jpg" />

    <link rel='stylesheet' href="//fonts.googleapis.com/css?family=Open+Sans:300,400italic,400,600,700|Alegreya+SC:700" />
    <link rel="stylesheet" href="/css/3HrCRVwL3Gos2V4HzXAw/Om/nxs=.css" />

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-32188490-1', 'stelfox.net');
      ga('require', 'displayfeatures');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header class='masthead'>
      <div class='masthead-inner'>
        <h1><a href='/' title='Home'>Sam Stelfox</a></h1>
        <p class='lead'>Thoughts from a systems hacker and developer.</p>
        <nav>
          <ul>
            <li><a href="/about/" title="About">About</a></li>
            <li><a href="/blog/" title="Blog">Blog</a></li>
            <li><a href="/knowledge_base/" title="Knowledge Base">Knowledge Base</a></li>
            <li><form action="/search/" method="get"><input type="search" name="q" placeholder="Search" /></form></li>
          </ul>
        </nav>
        <footer class='colophon'>
          <p>&copy; 2014, All rights reserved.</p>
        </footer>
      </div>
    </header>
    <div class='content container'>
      <div class='post'>
        <h1><a href="/blog/2012/02/rubys-xmlrpc-client-and-ssl/">Ruby's XMLRPC::Client and SSL</a></h1>
        <aside class="post-date">Published <time datetime=''>instead of an afternoon nap on February 14, 2012</time> by Sam Stelfox</aside>
        <article>
          <p>For the past few days I&#39;ve been working on a Ruby project that needed to
interact with a remote XMLRPC API. This isn&#39;t particularly unusual but it was
the first time from within a Ruby application. Luckily enough Ruby has a built
in XMLRPC client that handles a lot of the messy bits.</p>

<p>The XMLRPC::Client class itself seems fairly simple. There are only a handful
of methods, five of which are for opening a new connection in a few different
ways, and at least two ways to open each type of connection.</p>

<p>As a starting point this was a simplified chunk of code that I was using to
connect to the remote API:</p>
<div class="CodeRay">
  <div class="code"><pre>require <span class="string"><span class="delimiter">'</span><span class="content">xmlrpc/client</span><span class="delimiter">'</span></span>

<span class="keyword">class</span> <span class="class">APIConnection</span>
  <span class="keyword">def</span> <span class="function">initialize</span>(username, password, host)
    <span class="comment"># Build the arguments for the XMLRPC::Client object</span>
    conn_args = {
      <span class="symbol">:user</span> =&gt; username,
      <span class="symbol">:password</span> =&gt; password,
      <span class="symbol">:host</span> =&gt; host,
      <span class="symbol">:use_ssl</span> =&gt; <span class="predefined-constant">true</span>,
      <span class="symbol">:path</span> =&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>
    }

    <span class="instance-variable">@connection</span> = <span class="constant">XMLRPC</span>::<span class="constant">Client</span>.new_from_hash(conn_args)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">version</span>
    <span class="instance-variable">@connection</span>.call(<span class="string"><span class="delimiter">&quot;</span><span class="content">version</span><span class="delimiter">&quot;</span></span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>

<p>The problem I ran into was when connecting to a server using HTTPS. I knew that
this certificate was good however I continued to get the message:</p>

<blockquote>
<p>warning: peer certificate won&#39;t be verified in this SSL session</p>
</blockquote>

<p>Ruby has taken the approach of by default not including any trusted certificate
authorities which I greatly appreciate especially considering that in 2010 and
2011 12 certificate authorities were known to have been hacked including major
ones such as <a href="http://www.informationweek.com/news/security/management/232600406">VeriSign</a>, and <a href="http://www.symantec.com/connect/blogs/diginotar-ssl-breach-update">DigiNotar</a>. Some of which were <a href="http://nakedsecurity.sophos.com/2011/08/29/falsely-issued-google-ssl-certificate-in-the-wild-for-more-than-5-weeks/">proven</a>
to have issued false certificates.</p>

<p>Since XMLRPC::Client doesn&#39;t expose it&#39;s SSL trust settings through it&#39;s
methods I went on a bit of a journey through Google to find an answer. What I
found was overly disturbing, a lot of people don&#39;t seem to understand what SSL
is actually for. The solutions I found from the most egregious to least:</p>

<ul>
<li>Disabling OpenSSL certificate checking globally with
 OpenSSL::SSL::VERIFY_NONE</li>
<li>Overriding the Net::HTTP certificate checking</li>
<li>Disabling OpenSSL certificate checking locally by extending XMLRPC::Client
and over-riding how it was establishing connections</li>
<li>Using an SSL stripping proxy</li>
</ul>

<p>I couldn&#39;t find a solution out there that didn&#39;t the security conscious voice
in my head scream in despair. I asked on <a href="http://stackoverflow.com/questions/9199660/why-is-ruby-unable-to-verify-an-ssl-certificate">StackOverflow</a> for a good
solution. When I asked I didn&#39;t have a good grasp on how Ruby was handling SSL
certificates at all. The thorough answer from <a href="http://stackoverflow.com/a/9238221/95114">emboss</a> didn&#39;t quite answer
my question but it gave me more than enough to really hunt down what I wanted.</p>

<p>First stop, I needed the certificates that I&#39;ll be using to verify the
connection. Every single certificate authority that issues certificates for
public websites makes the public portion of their certificates available and
this is what we need to verify the connection. To find out which ones you
specifically need you can go to the API server&#39;s address and look at it&#39;s
certificate information by clicking on the site&#39;s lock icon. Every browser is a
little different so you&#39;ll have to find this out on your own. With Chrome (and
perhaps others) you can download each of the certificates in the chain that
you&#39;ll need to verify the server&#39;s certificate.</p>

<p>The server I was connecting to was using a <a href="http://www.rapidssl.com/">RapidSSL</a> certificate, who has
been verified by <a href="http://www.geotrust.com/">GeoTrust</a>. You want to grab their certificates base64
encoded in PEM format. Stick them all in a &quot;ca.crt&quot; file. For these two CAs
you&#39;re file will look a lot like this one:</p>
<div class="CodeRay">
  <div class="code"><pre>-----BEGIN CERTIFICATE-----
MIID1TCCAr2gAwIBAgIDAjbRMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTAwMjE5MjI0NTA1WhcNMjAwMjE4MjI0NTA1WjA8MQswCQYDVQQG
EwJVUzEXMBUGA1UEChMOR2VvVHJ1c3QsIEluYy4xFDASBgNVBAMTC1JhcGlkU1NM
IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAx3H4Vsce2cy1rfa0
l6P7oeYLUF9QqjraD/w9KSRDxhApwfxVQHLuverfn7ZB9EhLyG7+T1cSi1v6kt1e
6K3z8Buxe037z/3R5fjj3Of1c3/fAUnPjFbBvTfjW761T4uL8NpPx+PdVUdp3/Jb
ewdPPeWsIcHIHXro5/YPoar1b96oZU8QiZwD84l6pV4BcjPtqelaHnnzh8jfyMX8
N8iamte4dsywPuf95lTq319SQXhZV63xEtZ/vNWfcNMFbPqjfWdY3SZiHTGSDHl5
HI7PynvBZq+odEj7joLCniyZXHstXZu8W1eefDp6E63yoxhbK1kPzVw662gzxigd
gtFQiwIDAQABo4HZMIHWMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUa2k9ahhC
St2PAmU5/TUkhniRFjAwHwYDVR0jBBgwFoAUwHqYaI2J+6sFZAwRfap9ZbjKzE4w
EgYDVR0TAQH/BAgwBgEB/wIBADA6BgNVHR8EMzAxMC+gLaArhilodHRwOi8vY3Js
Lmdlb3RydXN0LmNvbS9jcmxzL2d0Z2xvYmFsLmNybDA0BggrBgEFBQcBAQQoMCYw
JAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmdlb3RydXN0LmNvbTANBgkqhkiG9w0B
AQUFAAOCAQEAq7y8Cl0YlOPBscOoTFXWvrSY8e48HM3P8yQkXJYDJ1j8Nq6iL4/x
/torAsMzvcjdSCIrYA+lAxD9d/jQ7ZZnT/3qRyBwVNypDFV+4ZYlitm12ldKvo2O
SUNjpWxOJ4cl61tt/qJ/OCjgNqutOaWlYsS3XFgsql0BYKZiZ6PAx2Ij9OdsRu61
04BqIhPSLT90T+qvjF+0OJzbrs6vhB6m9jRRWXnT43XcvNfzc9+S7NIgWW+c+5X4
knYYCnwPLKbK3opie9jzzl9ovY8+wXS7FXI6FoOpC+ZNmZzYV+yoAVHHb1c0XqtK
LEL2TxyJeN4mTvVvk0wVaydWTQBUbHq3tw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMDIwNTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQG
EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3Qg
R2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD9
9BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9mOSm9BXiLnTjoBbdq
fnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIuT8rxh0PBFpVXLVDv
iS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386DGXHKTubU
1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+
bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoW
MPRfwCvocWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTA
ephojYn7qwVkDBF9qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1l
uMrMTjANBgkqhkiG9w0BAQUFAAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKIn
Z57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VSsyShNwrrZHYqLizz/Tt1kL/6cdjHPTfS
tQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfOEVEiIuCl6rYVSAlk6l5PdPcF
PseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQdtqvmlKXBx4Ot2/Un
hw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeXxx12E6nV
5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==
-----END CERTIFICATE-----
</pre></div>
</div>

<p>Ugly right? That&#39;s what ruby needs though. But how do we get XMLRPC::Client to
actually use that information without hacking it all to pieces? Net::HTTP has a
few methods that allow you to set the appropriate connection settings and
XMLRPC::Client uses Net::HTTP. If XMLRPC::Client allowed to you specify this
directly somehow I would&#39;ve been a lot happier.</p>

<p>Here&#39;s that code snippet again, this time forcing certificate verification with
the ca.crt file. This code assumes that the ca.crt file lives in the same
directory as the connection script:</p>
<div class="CodeRay">
  <div class="code"><pre>require <span class="string"><span class="delimiter">'</span><span class="content">xmlrpc/client</span><span class="delimiter">'</span></span>

<span class="keyword">class</span> <span class="class">APIConnection</span>
  <span class="keyword">def</span> <span class="function">initialize</span>(username, password, host)
    <span class="comment"># Build the arguments for the XMLRPC::Client object</span>
    conn_args = {
      <span class="symbol">:user</span> =&gt; username,
      <span class="symbol">:password</span> =&gt; password,
      <span class="symbol">:host</span> =&gt; host,
      <span class="symbol">:use_ssl</span> =&gt; <span class="predefined-constant">true</span>,
      <span class="symbol">:path</span> =&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>
    }

    <span class="instance-variable">@connection</span> = <span class="constant">XMLRPC</span>::<span class="constant">Client</span>.new_from_hash(conn_args)

    <span class="instance-variable">@connection</span>.instance_variable_get(<span class="string"><span class="delimiter">&quot;</span><span class="content">@http</span><span class="delimiter">&quot;</span></span>).verify_mode = <span class="constant">OpenSSL</span>::<span class="constant">SSL</span>::<span class="constant">VERIFY_PEER</span>
    <span class="instance-variable">@connection</span>.instance_variable_get(<span class="string"><span class="delimiter">&quot;</span><span class="content">@http</span><span class="delimiter">&quot;</span></span>).ca_file = <span class="constant">File</span>.join(<span class="constant">File</span>.dirname(<span class="predefined-constant">__FILE__</span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">ca.crt</span><span class="delimiter">&quot;</span></span>)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">version</span>
    <span class="instance-variable">@connection</span>.call(<span class="string"><span class="delimiter">&quot;</span><span class="content">version</span><span class="delimiter">&quot;</span></span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>

<p>Those last two lines in the initialize method first dive into the connection
we&#39;ve already setup (but before it&#39;s been called), grab the of Net::HTTP and
tells it to force peer verification and to use the certificate file we created
before. No more warning, and we&#39;re actually safe.</p>

        </article>
      </div>
    </div>
  </body>
</html>
