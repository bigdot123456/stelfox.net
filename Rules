#!/usr/bin/env ruby

require 'json'

# A few helpful tips about the Rules file:
#
# * The string given to #compile and #route are matching patterns for
#   identifiers--not for paths. Therefore, you can’t match on extension.
#
# * The order of rules is important: for each item, only the first matching
#   rule is applied.
#
# * Item identifiers start and end with a slash (e.g. “/about/” for the file
#   “content/about.html”). To select all children, grandchildren, … of an
#   item, use the pattern “/about/*/”; “/about/*” will also select the parent,
#   because “*” matches zero or more characters.

preprocess do
  def build_search_index
    # Start with a base index
    index = {
      keywords: {},
      paths: [],
      weights: {}
    }

    # Loop through all the non-binary documents, for indexing, and focus initially on 
    @items.each do |i|
      next unless i.raw_content

      # Create and store the ID of the path
      index[:paths].push(i.identifier)
      path_id = index[:paths].index(i.identifier)

      i.raw_content.split(/[<>\s]+/).each do |word|
        word.downcase!
        word.gsub!(/[.,?!;"-'`*_]/, "") # Strip out any punctuation or markdown symbols
        word.strip!

        next unless word =~ /\A[a-z]{3,}\Z/
        next if STOP_WORDS.include?(word)

        index[:keywords][word] ||= []
        index[:keywords][word].push(path_id) unless index[:keywords][word].include?(path_id)

        index[:weights][word] ||= {}
        index[:weights][word][path_id] ||= 0
        index[:weights][word][path_id] += ((i[:tags] || []).include?(word) ? 5 : 1)
      end

      # Clean up any weights under the threshold, this makes the search less
      # accurate especially for highly specific words, but leaving it out
      # increases the index size by ~150%
      index[:weights].each do |word, path_weights|
        path_weights.each do |path, weight|
          index[:weights][word].delete(path) if weight <= 1
        end

        if index[:weights][word].empty?
          index[:weights].delete(word)
          index[:keywords].delete(word)
        end
      end
    end

    @items << Nanoc::Item.new(JSON.generate(index), {hidden: true}, '/search_index/')
  end

  def create_tag_pages
    # Build up a reverse association between tags and items
    tag_list = items.map { |i| (i[:tags] || []) }.flatten
    tag_counts = Hash.new(0)
    tag_list.each { |t| tag_counts[t] += 1 }
    tag_list.uniq!

    # Create a page item for each of various tags
    tag_list.uniq.each do |t|
      @items << Nanoc::Item.new(
        "<%= render 'tag_page', { tag: @tag, tagged_items: @tagged_items } %>",
        {extension: "erb", type: 'tag_page', title: t.gsub("-", " ").titleize },
        "/tags/#{t.to_url}/"
      )
    end

    # Create a tag index page
    @items << Nanoc::Item.new(
      "<%= render 'tag_index', { tag_list: #{tag_list.inspect} } %>",
      {extension: "erb", type: 'tag_index', title: "Tag List"},
      "/tags/"
    )
  end

  def create_knowledge_base_indexes
    kb_pages = @items.select { |i| i.identifier.to_s.start_with?("/knowledge_base/") }
    kb_pages.map! { |i| i.identifier.split("/")[0...-1].join("/") + "/" }
    kb_pages.uniq!.sort!.reject! { |i| @items[i] }
    kb_pages.each do |k|
      @items << Nanoc::Item.new(
        "<%= render 'kb_index' %>",
        {extension: "erb", type: 'kb_index', title: k.split("/")[-1].titleize},
        k
      )
    end
  end

  def generate_shortcodes
    map = {}

    # Generate short code URLs and map them to their URLs
    @site.config[:short_urls].each do |su|
      k = Digest::SHA1.base64digest(su)[0...6]
      map[k] = su
    end

    # Create a JSON representation of the url maps
    @items << Nanoc::Item.new(JSON.generate(map), {hidden: true}, '/short_codes/')

    @site.config[:short_url_map] = map
  end

  def reject_unpublished
    @items.reject! { |i| i[:published] == false }
  end

  reject_unpublished
  generate_shortcodes
  create_tag_pages
  create_knowledge_base_indexes
  build_search_index
end

# Handle processing of stylesheets
compile "/styles/_includes/*" do
  nil
end

compile "/styles/*" do
  filter :sass, syntax: :scss, style: :compact if item[:extension] == "scss"
  filter :rainpress
end

route "/styles/_includes/*" do
  nil
end

route "/styles/*" do
  # TODO: This only changes when the content of the individual file changes, we
  # need it after it's been processed :(
  "/css/#{item.raw_content.checksum}.css"
end

# Handle processing of javascripts
compile "/javascripts/*" do
  (item[:extension] || "").split('.').reverse_each do |e|
    filter :coffeescript if e == "coffee"
    filter :erb, {trim: "-<>"} if e == "erb"
  end

  # If mangling is enabled each javascript file needs to be self-contained as
  # coffee will not directly create top-level objects (the only thing excluded
  # from mangling)

  filter :uglify_js, compress: true, mangle: false
  #filter :uglify_js, mangle: false, output: { beautify: true, bracketize: true, semicolons: true }
end

route "/javascripts/*" do
  "/js/#{item.raw_content.checksum}.js"
end

# Yeah htaccess!
compile "/htaccess/" do
  filter :erb, {trim: "-<>"}
end

route "/htaccess/" do
  "/.htaccess"
end

compile "/short_codes/" do
  nil
end

route "/short_codes/" do
  "/short_codes.json"
end

compile "/sitemap" do
  # Remove items explicitely hidden, binary items and anything with an
  # extension that probably shouldn't be indexed by a search engine.
  items = @items.reject { |i| i.path.nil? || i[:hidden] || i.binary? }
  excluded_extensions = %w{ js css txt xml ttf }
  items.reject! { |i| excluded_extensions.include?(i.path.split('.').last) }

  filter :erb, { locals: { sitemap_items: items }, trim: "-<>" }
end

route "/sitemap" do
  "/sitemap.xml"
end

compile "/atom" do
  filter :erb, {trim: "-<>"}
end

route "/atom" do
  "/atom.xml"
end

compile "/static/*" do
  # Do nothing
end

route "/static/*" do
  item.identifier.chop + "." + item[:extension]
end

# Compile tag specific pages
compile "/tags/*/" do
  tag = item.identifier.match(%r{/tags/(.+)/}).captures.first
  tagged_items = items.select { |i| (i[:tags] || []).include?(tag) }

  filter :erb, { locals: { tag: tag, tagged_items: tagged_items }, trim: "-<>"}
  layout "default"
end

compile "/search_index/" do
  nil
end

route "/search_index/" do
  "/search_index.json"
end

# Handle remaining items
excluded_extensions = %w{ txt xml ttf }

compile "*" do
  if item.binary?
    # don’t filter binary items
  else
    item[:extension].split(".").reverse_each do |e|
      filter :erb, {trim: "-<>"} if e == "erb"

      if e == "md"
        filter :redcarpet,
          options: {
            autolink: true,
            disable_indented_code_blocks: true,
            fenced_code_blocks: true,
            highlight: true,
            lax_spacing: true,
            no_intra_emphasis: true,
            space_after_headers: true,
            strikethrough: true,
            superscript: true,
            tables: true,
            underline: true
          },
          renderer: HTMLWithCoderay
      end
    end

    if @item[:layout]
      layout @item[:layout]
    else
      layout "default" unless excluded_extensions.include?(item[:extension])
    end
  end
end

route "/blog/*/" do
  time, slug = item[:created_at], item[:title].to_url
  "/blog/#{time.year}/#{sprintf("%02d", time.month)}/#{slug}/index.html"
end

route "*" do
  if item.binary? || excluded_extensions.include?(item[:extension])
    # Write item with identifier /foo/ to /foo.ext
    item.identifier.chop + "." + item[:extension]
  else
    # Write item with identifier /foo/ to /foo/index.html
    item.identifier + "index.html"
  end
end

layout "*", :erb, {trim: "-<>"}

